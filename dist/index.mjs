// src/service.ts
import OpenAI from "openai";
import Replicate from "replicate";
var AIService = class {
  constructor(config = {}) {
    this.replicate = null;
    const openrouterKey = config.openrouterApiKey || process.env.OPENROUTER_API_KEY;
    const openaiKey = config.openaiApiKey || process.env.OPENAI_API_KEY;
    const replicateToken = config.replicateApiToken || process.env.REPLICATE_API_TOKEN;
    this.useOpenRouter = !!openrouterKey;
    this.useReplicate = !!replicateToken;
    this.imageModel = config.imageModel || process.env.OPENAI_IMAGE_MODEL || "dall-e-3";
    this.ttsModel = config.ttsModel || process.env.OPENAI_TTS_MODEL || "tts-1";
    this.whisperModel = config.whisperModel || process.env.OPENAI_WHISPER_MODEL || "whisper-1";
    this.moderationModel = config.moderationModel || process.env.OPENAI_MODERATION_MODEL || "omni-moderation-latest";
    this.chatModel = config.chatModel || "openai/gpt-4o";
    if (openrouterKey) {
      this.openrouter = new OpenAI({
        apiKey: openrouterKey,
        baseURL: config.openrouterBaseUrl || process.env.OPENROUTER_BASE_URL || "https://openrouter.ai/api/v1",
        defaultHeaders: {
          "HTTP-Referer": config.openrouterReferer || process.env.OPENROUTER_REFERER || "http://localhost:3000",
          "X-Title": config.openrouterTitle || process.env.OPENROUTER_TITLE || "PerkOS AI Service"
        }
      });
    } else {
      this.openrouter = new OpenAI({ apiKey: "dummy" });
    }
    if (replicateToken) {
      this.replicate = new Replicate({ auth: replicateToken });
    }
    if (openaiKey) {
      this.openai = new OpenAI({ apiKey: openaiKey });
    } else if (!openrouterKey) {
      throw new Error("Either OPENROUTER_API_KEY or OPENAI_API_KEY must be set");
    } else {
      this.openai = new OpenAI({ apiKey: "dummy" });
    }
  }
  getChatClient() {
    return this.useOpenRouter ? this.openrouter : this.openai;
  }
  getChatModel() {
    return this.useOpenRouter ? this.chatModel : "gpt-4o";
  }
  // Vision & Audio Methods
  async analyzeImage(imageInput, question = "What is in this image?") {
    let url = imageInput;
    if (!imageInput.startsWith("http") && !imageInput.startsWith("data:")) {
      url = `data:image/jpeg;base64,${imageInput}`;
    }
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [{ role: "user", content: [{ type: "text", text: question }, { type: "image_url", image_url: { url } }] }]
    });
    return response.choices[0].message.content || "Unable to analyze the image";
  }
  async generateImage(prompt, size = "1024x1024") {
    try {
      const response = await this.openai.images.generate({
        model: this.imageModel,
        prompt,
        n: 1,
        size,
        response_format: "b64_json"
      });
      if (!response.data || response.data.length === 0) throw new Error("No image generated");
      const image = response.data[0];
      return { base64: image.b64_json, revisedPrompt: image.revised_prompt };
    } catch (error) {
      if ((error?.status === 403 || error?.message?.includes("does not have access")) && this.useReplicate && this.replicate) {
        return this.generateImageWithReplicate(prompt, size);
      }
      throw error;
    }
  }
  async generateImageWithReplicate(prompt, size = "1024x1024") {
    if (!this.replicate) throw new Error("Replicate client not initialized");
    const [width, height] = size.split("x").map(Number);
    const aspectRatio = width === height ? "1:1" : width > height ? "16:9" : "9:16";
    const output = await this.replicate.run(
      "black-forest-labs/flux-schnell",
      { input: { prompt, aspect_ratio: aspectRatio, output_format: "png", output_quality: 90 } }
    );
    if (!output || output.length === 0) throw new Error("No image generated by Replicate");
    const imageUrl = output[0];
    const imageResponse = await fetch(imageUrl);
    const arrayBuffer = await imageResponse.arrayBuffer();
    const base64 = Buffer.from(arrayBuffer).toString("base64");
    return { base64, url: imageUrl, revisedPrompt: prompt };
  }
  async transcribeAudio(audioInput) {
    if (!this.replicate) throw new Error("Replicate API token required for audio transcription");
    return this.transcribeWithReplicate(audioInput);
  }
  async transcribeWithReplicate(audioInput) {
    if (!this.replicate) throw new Error("Replicate client not initialized");
    let dataUri;
    if (typeof audioInput === "string") {
      if (audioInput.startsWith("http")) {
        const response = await fetch(audioInput);
        const arrayBuffer = await response.arrayBuffer();
        const base64 = Buffer.from(arrayBuffer).toString("base64");
        const mimeType = response.headers.get("content-type") || "audio/mpeg";
        dataUri = `data:${mimeType};base64,${base64}`;
      } else if (audioInput.startsWith("data:")) {
        dataUri = audioInput;
      } else {
        throw new Error("Invalid string input for transcription");
      }
    } else {
      const arrayBuffer = await audioInput.arrayBuffer();
      const base64 = Buffer.from(arrayBuffer).toString("base64");
      const mimeType = audioInput.type || "audio/mpeg";
      dataUri = `data:${mimeType};base64,${base64}`;
    }
    const output = await this.replicate.run(
      "openai/whisper:4d50797290df275329f202e48c76360b3f22b08d28c196cbc54600319435f8d2",
      { input: { audio: dataUri, model: "large-v3", language: "en", translate: false } }
    );
    return output.transcription || "";
  }
  async synthesizeSpeech(text, voice = "alloy") {
    if (!this.replicate) throw new Error("Replicate API token required for speech synthesis");
    return this.synthesizeWithReplicate(text);
  }
  async synthesizeWithReplicate(text) {
    if (!this.replicate) throw new Error("Replicate client not initialized");
    const output = await this.replicate.run(
      "minimax/speech-02-turbo",
      { input: { text, voice_id: "Friendly_Person" } }
    );
    if (!output) throw new Error("No audio generated by Replicate");
    const audioResponse = await fetch(output);
    const arrayBuffer = await audioResponse.arrayBuffer();
    return Buffer.from(arrayBuffer);
  }
  // NLP Methods
  async summarizeText(text, length = "medium") {
    const lengthInstructions = { short: "in 2-3 sentences", medium: "in 1-2 paragraphs", long: "in 3-4 paragraphs with key points" };
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: "You are a professional summarization assistant." },
        { role: "user", content: `Summarize the following text ${lengthInstructions[length]}:

${text}` }
      ],
      temperature: 0.3
    });
    return response.choices[0].message.content || "Unable to generate summary";
  }
  async translateText(text, sourceLang, targetLang) {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Translate accurately from ${sourceLang} to ${targetLang}.` },
        { role: "user", content: text }
      ],
      temperature: 0.2
    });
    return { translation: response.choices[0].message.content || "", confidence: 0.95 };
  }
  async analyzeSentiment(text) {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: 'Analyze sentiment. Respond with JSON: {"sentiment": "positive"|"negative"|"neutral", "score": 0.0-1.0, "emotions": []}' },
        { role: "user", content: text }
      ],
      temperature: 0.1,
      response_format: { type: "json_object" }
    });
    const result = JSON.parse(response.choices[0].message.content || "{}");
    return { sentiment: result.sentiment || "neutral", score: result.score || 0.5, emotions: result.emotions || [] };
  }
  async moderateContent(content) {
    try {
      const moderation = await this.openai.moderations.create({ input: content, model: this.moderationModel });
      const result = moderation.results[0];
      return {
        flagged: result.flagged,
        categories: result.categories,
        categoryScores: result.category_scores
      };
    } catch {
      const response = await this.getChatClient().chat.completions.create({
        model: this.getChatModel(),
        messages: [
          { role: "system", content: 'Analyze content for policy violations. Respond with JSON: {"flagged": bool, "categories": {}, "categoryScores": {}}' },
          { role: "user", content: `Analyze: ${content}` }
        ],
        temperature: 0.1,
        response_format: { type: "json_object" }
      });
      return JSON.parse(response.choices[0].message.content || '{"flagged":false,"categories":{},"categoryScores":{}}');
    }
  }
  async simplifyText(text, readingLevel = "middle") {
    const levelInstructions = {
      elementary: "5th grade reading level",
      middle: "8th grade reading level",
      high: "high school reading level"
    };
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Rewrite at ${levelInstructions[readingLevel]}.` },
        { role: "user", content: text }
      ],
      temperature: 0.3
    });
    return response.choices[0].message.content || text;
  }
  async extractEntities(text) {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: 'Extract entities. Respond with JSON: {"entities": [{"text": "", "type": "", "position": 0}]}' },
        { role: "user", content: text }
      ],
      temperature: 0.1,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"entities":[]}');
  }
  // Business Tools
  async generateEmail(purpose, tone = "formal", keyPoints) {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Generate ${tone} email. Respond with JSON: {"subject": "", "body": ""}` },
        { role: "user", content: `Purpose: ${purpose}
Key points:
${keyPoints.map((p) => `- ${p}`).join("\n")}` }
      ],
      temperature: 0.4,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"subject":"","body":""}');
  }
  async generateProductDescription(productName, features, targetAudience) {
    const audienceText = targetAudience ? `
Target audience: ${targetAudience}` : "";
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: "Create compelling, SEO-optimized product descriptions." },
        { role: "user", content: `Product: ${productName}
Features:
${features.map((f) => `- ${f}`).join("\n")}${audienceText}` }
      ],
      temperature: 0.5
    });
    return response.choices[0].message.content || "";
  }
  async optimizeSEO(content, keywords) {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: 'Optimize for SEO. Respond with JSON: {"optimizedContent": "", "analysis": ""}' },
        { role: "user", content: `Content:
${content}

Keywords: ${keywords.join(", ")}` }
      ],
      temperature: 0.4,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"optimizedContent":"","analysis":""}');
  }
  // Developer Tools
  async generateCode(description, language, framework) {
    const frameworkText = framework ? ` using ${framework}` : "";
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Generate ${language} code. Respond with JSON: {"code": "", "explanation": ""}` },
        { role: "user", content: `Generate ${language} code${frameworkText}: ${description}` }
      ],
      temperature: 0.2,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"code":"","explanation":""}');
  }
  async reviewCode(code, language) {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Review ${language} code. Respond with JSON: {"issues": [], "suggestions": [], "securityConcerns": []}` },
        { role: "user", content: code }
      ],
      temperature: 0.1,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"issues":[],"suggestions":[],"securityConcerns":[]}');
  }
  async generateSQLQuery(schema, query) {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: 'Generate SQL. Respond with JSON: {"query": "", "explanation": ""}' },
        { role: "user", content: `Schema:
${schema}

Generate SQL for: ${query}` }
      ],
      temperature: 0.1,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"query":"","explanation":""}');
  }
  async generateRegex(description) {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: 'Generate regex. Respond with JSON: {"pattern": "", "explanation": "", "examples": []}' },
        { role: "user", content: description }
      ],
      temperature: 0.1,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"pattern":"","explanation":"","examples":[]}');
  }
  async generateAPIDocs(code, framework) {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Generate API docs for ${framework}. Respond with JSON: {"documentation": "", "openapi": ""}` },
        { role: "user", content: code }
      ],
      temperature: 0.3,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"documentation":""}');
  }
  async extractTextOCR(image) {
    const url = image.startsWith("data:image") ? image : `data:image/jpeg;base64,${image}`;
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: "Extract all text from the image accurately." },
        { role: "user", content: [{ type: "text", text: "Extract all text:" }, { type: "image_url", image_url: { url } }] }
      ]
    });
    return { text: response.choices[0].message.content || "", confidence: 0.95 };
  }
  async generateQuiz(topic, numQuestions = 5, difficulty = "medium") {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Generate ${difficulty} quiz. Respond with JSON: {"questions": [{"question": "", "options": [], "correctIndex": 0, "explanation": ""}]}` },
        { role: "user", content: `Topic: ${topic}
Questions: ${numQuestions}` }
      ],
      temperature: 0.5,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"questions":[]}');
  }
};
export {
  AIService
};
//# sourceMappingURL=index.mjs.map