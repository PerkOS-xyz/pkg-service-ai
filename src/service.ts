/**
 * AI Service Implementation
 * Multi-provider AI service with OpenRouter, Replicate, and OpenAI support
 */

import OpenAI from "openai";
import Replicate from "replicate";
import type {
  AIServiceConfig,
  ImageGenerateResult,
  TranslationResult,
  SentimentResult,
  ModerationResult,
  EntityResult,
  EmailResult,
  CodeGenerateResult,
  CodeReviewResult,
  SQLResult,
  RegexResult,
  SEOResult,
  APIDocsResult,
  OCRResult,
  QuizResult,
  SummaryLength,
  ReadingLevel,
  EmailTone,
  Difficulty,
  Voice,
} from "./types";

export class AIService {
  private openai: OpenAI;
  private openrouter: OpenAI;
  private replicate: Replicate | null = null;
  private useOpenRouter: boolean;
  private useReplicate: boolean;

  private imageModel: string;
  private ttsModel: string;
  private whisperModel: string;
  private moderationModel: string;
  private chatModel: string;

  constructor(config: AIServiceConfig = {}) {
    const openrouterKey = config.openrouterApiKey || process.env.OPENROUTER_API_KEY;
    const openaiKey = config.openaiApiKey || process.env.OPENAI_API_KEY;
    const replicateToken = config.replicateApiToken || process.env.REPLICATE_API_TOKEN;

    this.useOpenRouter = !!openrouterKey;
    this.useReplicate = !!replicateToken;

    // Model configuration
    this.imageModel = config.imageModel || process.env.OPENAI_IMAGE_MODEL || "dall-e-3";
    this.ttsModel = config.ttsModel || process.env.OPENAI_TTS_MODEL || "tts-1";
    this.whisperModel = config.whisperModel || process.env.OPENAI_WHISPER_MODEL || "whisper-1";
    this.moderationModel = config.moderationModel || process.env.OPENAI_MODERATION_MODEL || "omni-moderation-latest";
    this.chatModel = config.chatModel || "openai/gpt-4o";

    if (openrouterKey) {
      this.openrouter = new OpenAI({
        apiKey: openrouterKey,
        baseURL: config.openrouterBaseUrl || process.env.OPENROUTER_BASE_URL || "https://openrouter.ai/api/v1",
        defaultHeaders: {
          "HTTP-Referer": config.openrouterReferer || process.env.OPENROUTER_REFERER || "http://localhost:3000",
          "X-Title": config.openrouterTitle || process.env.OPENROUTER_TITLE || "PerkOS AI Service",
        },
      });
    } else {
      this.openrouter = new OpenAI({ apiKey: "dummy" });
    }

    if (replicateToken) {
      this.replicate = new Replicate({ auth: replicateToken });
    }

    if (openaiKey) {
      this.openai = new OpenAI({ apiKey: openaiKey });
    } else if (!openrouterKey) {
      throw new Error("Either OPENROUTER_API_KEY or OPENAI_API_KEY must be set");
    } else {
      this.openai = new OpenAI({ apiKey: "dummy" });
    }
  }

  private getChatClient(): OpenAI {
    return this.useOpenRouter ? this.openrouter : this.openai;
  }

  private getChatModel(): string {
    return this.useOpenRouter ? this.chatModel : "gpt-4o";
  }

  // Vision & Audio Methods

  async analyzeImage(imageInput: string, question: string = "What is in this image?"): Promise<string> {
    let url = imageInput;
    if (!imageInput.startsWith("http") && !imageInput.startsWith("data:")) {
      url = `data:image/jpeg;base64,${imageInput}`;
    }

    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [{ role: "user", content: [{ type: "text", text: question }, { type: "image_url", image_url: { url } }] }],
    });

    return response.choices[0].message.content || "Unable to analyze the image";
  }

  async generateImage(prompt: string, size: "1024x1024" | "1792x1024" | "1024x1792" = "1024x1024"): Promise<ImageGenerateResult> {
    try {
      const response = await this.openai.images.generate({
        model: this.imageModel,
        prompt, n: 1, size, response_format: "b64_json",
      });
      if (!response.data || response.data.length === 0) throw new Error("No image generated");
      const image = response.data[0];
      return { base64: image.b64_json, revisedPrompt: image.revised_prompt };
    } catch (error: any) {
      if ((error?.status === 403 || error?.message?.includes("does not have access")) && this.useReplicate && this.replicate) {
        return this.generateImageWithReplicate(prompt, size);
      }
      throw error;
    }
  }

  private async generateImageWithReplicate(prompt: string, size: "1024x1024" | "1792x1024" | "1024x1792" = "1024x1024"): Promise<ImageGenerateResult> {
    if (!this.replicate) throw new Error("Replicate client not initialized");

    const [width, height] = size.split("x").map(Number);
    const aspectRatio = width === height ? "1:1" : width > height ? "16:9" : "9:16";

    const output = await this.replicate.run(
      "black-forest-labs/flux-schnell",
      { input: { prompt, aspect_ratio: aspectRatio, output_format: "png", output_quality: 90 } }
    ) as string[];

    if (!output || output.length === 0) throw new Error("No image generated by Replicate");

    const imageUrl = output[0];
    const imageResponse = await fetch(imageUrl);
    const arrayBuffer = await imageResponse.arrayBuffer();
    const base64 = Buffer.from(arrayBuffer).toString("base64");

    return { base64, url: imageUrl, revisedPrompt: prompt };
  }

  async transcribeAudio(audioInput: File | Blob | string): Promise<string> {
    if (!this.replicate) throw new Error("Replicate API token required for audio transcription");
    return this.transcribeWithReplicate(audioInput);
  }

  private async transcribeWithReplicate(audioInput: File | Blob | string): Promise<string> {
    if (!this.replicate) throw new Error("Replicate client not initialized");

    let dataUri: string;

    if (typeof audioInput === "string") {
      if (audioInput.startsWith("http")) {
        const response = await fetch(audioInput);
        const arrayBuffer = await response.arrayBuffer();
        const base64 = Buffer.from(arrayBuffer).toString("base64");
        const mimeType = response.headers.get("content-type") || "audio/mpeg";
        dataUri = `data:${mimeType};base64,${base64}`;
      } else if (audioInput.startsWith("data:")) {
        dataUri = audioInput;
      } else {
        throw new Error("Invalid string input for transcription");
      }
    } else {
      const arrayBuffer = await audioInput.arrayBuffer();
      const base64 = Buffer.from(arrayBuffer).toString("base64");
      const mimeType = audioInput.type || "audio/mpeg";
      dataUri = `data:${mimeType};base64,${base64}`;
    }

    const output = await this.replicate.run(
      "openai/whisper:4d50797290df275329f202e48c76360b3f22b08d28c196cbc54600319435f8d2",
      { input: { audio: dataUri, model: "large-v3", language: "en", translate: false } }
    ) as { transcription: string };

    return output.transcription || "";
  }

  async synthesizeSpeech(text: string, voice: Voice = "alloy"): Promise<Buffer> {
    if (!this.replicate) throw new Error("Replicate API token required for speech synthesis");
    return this.synthesizeWithReplicate(text);
  }

  private async synthesizeWithReplicate(text: string): Promise<Buffer> {
    if (!this.replicate) throw new Error("Replicate client not initialized");

    const output = await this.replicate.run(
      "minimax/speech-02-turbo",
      { input: { text, voice_id: "Friendly_Person" } }
    ) as unknown as string;

    if (!output) throw new Error("No audio generated by Replicate");

    const audioResponse = await fetch(output);
    const arrayBuffer = await audioResponse.arrayBuffer();
    return Buffer.from(arrayBuffer);
  }

  // NLP Methods

  async summarizeText(text: string, length: SummaryLength = "medium"): Promise<string> {
    const lengthInstructions = { short: "in 2-3 sentences", medium: "in 1-2 paragraphs", long: "in 3-4 paragraphs with key points" };
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: "You are a professional summarization assistant." },
        { role: "user", content: `Summarize the following text ${lengthInstructions[length]}:\n\n${text}` }
      ],
      temperature: 0.3,
    });
    return response.choices[0].message.content || "Unable to generate summary";
  }

  async translateText(text: string, sourceLang: string, targetLang: string): Promise<TranslationResult> {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Translate accurately from ${sourceLang} to ${targetLang}.` },
        { role: "user", content: text }
      ],
      temperature: 0.2,
    });
    return { translation: response.choices[0].message.content || "", confidence: 0.95 };
  }

  async analyzeSentiment(text: string): Promise<SentimentResult> {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: 'Analyze sentiment. Respond with JSON: {"sentiment": "positive"|"negative"|"neutral", "score": 0.0-1.0, "emotions": []}' },
        { role: "user", content: text }
      ],
      temperature: 0.1,
      response_format: { type: "json_object" }
    });
    const result = JSON.parse(response.choices[0].message.content || "{}");
    return { sentiment: result.sentiment || "neutral", score: result.score || 0.5, emotions: result.emotions || [] };
  }

  async moderateContent(content: string): Promise<ModerationResult> {
    try {
      const moderation = await this.openai.moderations.create({ input: content, model: this.moderationModel });
      const result = moderation.results[0];
      return {
        flagged: result.flagged,
        categories: result.categories as unknown as Record<string, boolean>,
        categoryScores: result.category_scores as unknown as Record<string, number>,
      };
    } catch {
      const response = await this.getChatClient().chat.completions.create({
        model: this.getChatModel(),
        messages: [
          { role: "system", content: 'Analyze content for policy violations. Respond with JSON: {"flagged": bool, "categories": {}, "categoryScores": {}}' },
          { role: "user", content: `Analyze: ${content}` }
        ],
        temperature: 0.1,
        response_format: { type: "json_object" }
      });
      return JSON.parse(response.choices[0].message.content || '{"flagged":false,"categories":{},"categoryScores":{}}');
    }
  }

  async simplifyText(text: string, readingLevel: ReadingLevel = "middle"): Promise<string> {
    const levelInstructions = {
      elementary: "5th grade reading level",
      middle: "8th grade reading level",
      high: "high school reading level"
    };
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Rewrite at ${levelInstructions[readingLevel]}.` },
        { role: "user", content: text }
      ],
      temperature: 0.3,
    });
    return response.choices[0].message.content || text;
  }

  async extractEntities(text: string): Promise<EntityResult> {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: 'Extract entities. Respond with JSON: {"entities": [{"text": "", "type": "", "position": 0}]}' },
        { role: "user", content: text }
      ],
      temperature: 0.1,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"entities":[]}');
  }

  // Business Tools

  async generateEmail(purpose: string, tone: EmailTone = "formal", keyPoints: string[]): Promise<EmailResult> {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Generate ${tone} email. Respond with JSON: {"subject": "", "body": ""}` },
        { role: "user", content: `Purpose: ${purpose}\nKey points:\n${keyPoints.map(p => `- ${p}`).join('\n')}` }
      ],
      temperature: 0.4,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"subject":"","body":""}');
  }

  async generateProductDescription(productName: string, features: string[], targetAudience?: string): Promise<string> {
    const audienceText = targetAudience ? `\nTarget audience: ${targetAudience}` : '';
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: "Create compelling, SEO-optimized product descriptions." },
        { role: "user", content: `Product: ${productName}\nFeatures:\n${features.map(f => `- ${f}`).join('\n')}${audienceText}` }
      ],
      temperature: 0.5,
    });
    return response.choices[0].message.content || "";
  }

  async optimizeSEO(content: string, keywords: string[]): Promise<SEOResult> {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: 'Optimize for SEO. Respond with JSON: {"optimizedContent": "", "analysis": ""}' },
        { role: "user", content: `Content:\n${content}\n\nKeywords: ${keywords.join(', ')}` }
      ],
      temperature: 0.4,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"optimizedContent":"","analysis":""}');
  }

  // Developer Tools

  async generateCode(description: string, language: string, framework?: string): Promise<CodeGenerateResult> {
    const frameworkText = framework ? ` using ${framework}` : '';
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Generate ${language} code. Respond with JSON: {"code": "", "explanation": ""}` },
        { role: "user", content: `Generate ${language} code${frameworkText}: ${description}` }
      ],
      temperature: 0.2,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"code":"","explanation":""}');
  }

  async reviewCode(code: string, language: string): Promise<CodeReviewResult> {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Review ${language} code. Respond with JSON: {"issues": [], "suggestions": [], "securityConcerns": []}` },
        { role: "user", content: code }
      ],
      temperature: 0.1,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"issues":[],"suggestions":[],"securityConcerns":[]}');
  }

  async generateSQLQuery(schema: string, query: string): Promise<SQLResult> {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: 'Generate SQL. Respond with JSON: {"query": "", "explanation": ""}' },
        { role: "user", content: `Schema:\n${schema}\n\nGenerate SQL for: ${query}` }
      ],
      temperature: 0.1,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"query":"","explanation":""}');
  }

  async generateRegex(description: string): Promise<RegexResult> {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: 'Generate regex. Respond with JSON: {"pattern": "", "explanation": "", "examples": []}' },
        { role: "user", content: description }
      ],
      temperature: 0.1,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"pattern":"","explanation":"","examples":[]}');
  }

  async generateAPIDocs(code: string, framework: string): Promise<APIDocsResult> {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Generate API docs for ${framework}. Respond with JSON: {"documentation": "", "openapi": ""}` },
        { role: "user", content: code }
      ],
      temperature: 0.3,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"documentation":""}');
  }

  async extractTextOCR(image: string): Promise<OCRResult> {
    const url = image.startsWith("data:image") ? image : `data:image/jpeg;base64,${image}`;
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: "Extract all text from the image accurately." },
        { role: "user", content: [{ type: "text", text: "Extract all text:" }, { type: "image_url", image_url: { url } }] }
      ],
    });
    return { text: response.choices[0].message.content || "", confidence: 0.95 };
  }

  async generateQuiz(topic: string, numQuestions: number = 5, difficulty: Difficulty = "medium"): Promise<QuizResult> {
    const response = await this.getChatClient().chat.completions.create({
      model: this.getChatModel(),
      messages: [
        { role: "system", content: `Generate ${difficulty} quiz. Respond with JSON: {"questions": [{"question": "", "options": [], "correctIndex": 0, "explanation": ""}]}` },
        { role: "user", content: `Topic: ${topic}\nQuestions: ${numQuestions}` }
      ],
      temperature: 0.5,
      response_format: { type: "json_object" }
    });
    return JSON.parse(response.choices[0].message.content || '{"questions":[]}');
  }
}
